---
layout: post
title: "SQL Overview"
description: "Notes on Structured Query Language."
author: "Nathan Tsai"
toc: true
comments: false
# image: 
hide: false
search_exclude: true
show_tags: false
# sticky_rank: 1
categories: [sql, mysql, postgresql]
permalink: /sql-overview
---

# SQL Overview
* [Mode SQL]()
* [Select Star SQL]()
* [W3 Schools]()

## SQL
* **SQL**, or Structured Query Language, is a [declarative language](https://en.wikipedia.org/wiki/Declarative_programming) used to access and manipulate databases.
* SQL can execute queries, retrieve data, insert records, update records, and delete records.
* SQL can create new databases, tables, stored procedures, views.
* SQL can set permissions on tables, procedures, and views.

## RDBMS
* **RDBMS**, or Relational Database Management System, is the basis for SQL and all modern database systems (MS SQL Server, MySQL, etc.).
* A **database** is an organized collection of data tables.
* A **schema** is an overview of all tables in a database.
* A **table** is a collection of related data entries, formatted in columns and rows.
    * Every table is broken up into smaller entities called **fields**.
    * Reference a table using `database.table`.
* A **field** is a table column (vertical entity) designed to maintain specific information about every record in the table.
* A **record** is a table row (horizontal entity) that holds specific information about each individual entry that exists in a table.

## SQL Syntax
* SQL keywords are not case-sensitive.
* Semicolons separate each SQL statement, often used to execute more than one statement in the same query call.
* Use double-quotes for column names.
* Use `-- comment` for single line comments, `/* comment */` for multi-line comments

### SELECT
* Extracts data from a database

    ```sql
    -- Selecting all columns and rows
    SELECT *
    FROM db.table_name
    ```

### FROM
* Denotes the database and table to query

    ```sql
    -- Selecting all rows of col1
    SELECT col1
    FROM db.table_name
    ```

### WHERE
* Filters the data retrieved from the database based on a specified condition

    ```sql
    -- Filtering for rows where col1 is positive
    SELECT col1
    FROM db.table_name
    WHERE col1 > 0
    ```

| Comparison Operators      | Symbol |
| ------------------------- | ------ |
| Equal To                  | =      |
| Not Equal To              | <>, != |
| Greater Than              | >      |
| Greater Than or Equal To  | >=     |
| Less Than                 | <      |
| Less Than or Equal To     | <=     |

| Arithmetic Operators      | Symbol |
| ------------------------- | ------ |
| Addition                  | +      |
| Subtraction               | -      |
| Multiplication            | *      |
| Division                  | /      |

* Use operators to compare across columns in the same row.
    * Need aggregate functions to compare across rows.

| Logical Operators         | Symbol | Example |
| ------------------------- | ------ | --------|
| Match similar values      | `LIKE`, <br /> `%` is a multiple wildcard character, <br /> `_` is an individual wildcard character | ```WHERE col LIKE 'n%'``` |
| Match similar values, case insensitive | `ILIKE` | ```WHERE col LIKE 'n%'``` |
| Match on list of values, or query result | `IN` | ```WHERE col IN (1, 2, 3)``` |
| Match on a range, inclusive | `BETWEEN ... AND ...` | ```WHERE col BETWEEN 5 AND 10``` |
| Match null values | `IS NULL` | ```WHERE col IS NULL``` |
| Match non-null values | `IS NOT NULL` | ```WHERE col IS NOT NULL``` |
| Match on 2 conditions | `AND`| ```WHERE col >= 1 AND col <= 2``` |
| Match on either of 2 conditions | `OR`| ```WHERE col = 1 OR (col = 2 AND col = 3)``` |
| Match on not a condition | `NOT`| ```WHERE col NOT LIKE '%n%'``` <br /> ```WHERE col NOT BETWEEN 2 AND 3``` |

### ORDER BY
* Sorts data based on 1+ columns
* Ascending sort by default, use `DESC` for descending sort
* Can also use #s in place of column names, corresponding to (1-indexed) order of columns in `SELECT`

    ```sql
    -- Ordering using column names
    SELECT col1, col2
    FROM db.table_name
    ORDER BY col1 DESC, col2

    -- Ordering using column numbers
    SELECT col1, col2
    FROM db.table_name
    ORDER BY 1 DESC, 2
    ```


### Aggregate Functions

| Aggregation | Command | Example |
| --- | --- | --- |
| Gets count of all non-null values | `COUNT` | ```SELECT COUNT(col1)``` |
| Gets sum of all values, null values are 0 | `SUM` | ```SELECT SUM(col1)``` |
| Gets average of all values, null values are 0 | `AVG` | ```SELECT AVG(col1)``` |
| Gets minimum of all values | `MIN` | ```SELECT MIN(col1)``` |
| Gets maximum of all values | `MAX` |  ```SELECT MAX(col1)``` |


### AS (Aliasing)
* Renames a table or column

    ```sql
    SELECT col1 AS "Sales"
    FROM db.table AS T
    ```

### GROUP BY
* Aggregates across smaller groupings instead of the whole table
* Required for non-aggregated columns when performing aggregation
* Can also reference columns by 1-indexed order in `SELECT`
* Order of column names in grouping does not matter

    ```sql
    SELECT A, B, COUNT(C)
    FROM table_name
    GROUP BY A, B

    -- Equivalent query
    SELECT A, B, COUNT(C)
    FROM table_name
    GROUP BY 2, 1
    ```

### HAVING
* Filters the result of aggregate columns
* Like `WHERE` but for aggregated columns

    ```sql
    SELECT A, MAX(B)    -- max aggregation
    FROM db.table
    WHERE A >= 4        -- filter before aggregation
    GROUP BY A          -- group by non-aggregated cols
    HAVING MAX(B) > 10  -- filter after aggregation
    ORDER BY 2 DESC     -- descending sort by MAX(B)
    LIMIT 100           -- return only first 100 rows
    ```

### CASE WHEN
* Used to handle if/else logic
* Always goes in the `SELECT` clause
* Default value is `NULL` if no `ELSE` clause

    ```sql
    SELECT CASE
            WHEN condition THEN value
            WHEN condition THEN value
            ELSE value -- optional, default is NULL
        END AS col_name
    FROM db.table
    ```

* Use with aggregate functions to create different aggregation groups
    * can use `CASE WHEN` alias in `GROUP BY` or copy and paste the whole `CASE WHEN`

    ```sql
    -- vertical table example
    SELECT CASE -- processes all c values into 5 groups
            WHEN col=1 THEN 'Freshman'
            WHEN col=2 THEN 'Sophomore'
            WHEN col=3 THEN 'Junior'
            WHEN col=4 THEN 'Senior'
        ELSE 'None'
        END AS grade,
        COUNT(1) AS count
    FROM db.table
    GROUP BY grade  -- groups by grade

    -- horizontal table example
    SELECT 
        COUNT(CASE WHEN col=1 THEN 1 ELSE NULL END) AS fr_count,
        COUNT(CASE WHEN col=2 THEN 1 ELSE NULL END) AS so_count,
        COUNT(CASE WHEN col=3 THEN 1 ELSE NULL END) AS jr_count,
        COUNT(CASE WHEN col=4 THEN 1 ELSE NULL END) AS sr_count
    FROM db.table
    ```

### DISTINCT
* Selects unique values of 1+ columns
* Only need to include `DISTINCT` once
* Slow performance, especially in aggregations

    ```sql
    SELECT DISTINCT year, month
    FROM db.table

    -- use with aggregate
    SELECT COUNT(DISTINCT month) AS unique_months
    FROM db.table
    ```

### Joins
* Uses common identifiers to join related tables
    * Rows without matching common identifiers will default to `NULL`
* Use aliases for tables when joining
    * Aliases distinguish identical column names when joining two tables
* Can use aliases in `SELECT` clause, like `SELECT alias.col_name`

### JOIN/INNER JOIN
* Joins two tables, returns only matched rows from both tables
* Unmatched rows are not included

    ```sql
    -- Keeps matched rows
    SELECT A.*, B.col2
    FROM table1 A
    JOIN table2 B 
    ON A.col=B.col
    ```

### LEFT JOIN/LEFT OUTER JOIN
* Joins two tables, returns matched rows and unmatched rows from left table.

    ```sql
    -- Keeps all A rows and matched B rows
    SELECT A.*, B.col2
    FROM table1 A
    LEFT JOIN table2 B 
    ON A.col=B.col
    ```

### RIGHT JOIN/RIGHT OUTER JOIN
* Joins two tables, returns matched rows and unmatched rows from right table.
* Usually use flip the table order and use `LEFT JOIN`.

    ```sql
    -- Keeps match A rows and all B rows
    SELECT A.*, B.col2
    FROM table1 A
    RIGHT JOIN table2 B 
    ON A.col=B.col
    ```

### FULL OUTER JOIN
* Joins two tables, returns all matched and unmatched rows.
* Commonly used in aggregations to find overlap between two tables

    ```sql
    -- Keeps all matched/unmatched rows
    SELECT A.*, B.col2
    FROM table1 A
    JOIN table2 B 
    ON A.col=B.col

    -- Example
    SELECT
        COUNT(
            CASE WHEN A.a IS NOT NULL AND B.b IS NULL
            THEN A.a -- must use A.a otherwise NULL and COUNT will be 0
            ELSE NULL END
        ) AS A_only,
        COUNT(
            CASE WHEN A.a IS NOT NULL AND B.b IS NOT NULL
            THEN A.a -- can keep either A.a or B.b
            ELSE NULL END
        ) AS both,
        COUNT(
            CASE WHEN A.a IS NULL AND B.b IS NOT NULL
            THEN B.b -- must use B.b otherwise NULL and COUNT will be 0
            ELSE NULL END
        ) AS B_only
    FROM table1 A
    JOIN table2 B
    ON A.a = B.b
    ```

### Self Joins


### Joins with Conditions
* Can put conditions either in the `WHERE` or `ON` clauses

    ```sql
    -- Finds rows that fit the condition rather
    -- than joining all rows then filtering
    SELECT A.*, B.*
    FROM table1 A
    JOIN table2 B
    ON A.id = B.id
    AND A.year > B.year + 5
    ```

* Conditioning `WHERE` vs. `ON` clauses
    * `WHERE` joins all rows that match, then filters the rows based on that condition
        * May be less efficient when joining large tables
    * `ON` only joins rows that match the conditions listed
    * For `INNER JOIN`s, the two methods effectively produce the *same results* because unmatched (NULL) rows are discarded.
    * For `OUTER JOIN`s, this is a slight difference.

* Example
    * Tables

    **documents**
    | id | name |
    | -- | ---- |
    | 1  | doc1 |
    | 2  | doc2 |
    | 3  | doc3 |
    | 4  | doc4 |
    | 5  | doc5 |

    **downloads**
    | id | doc_id | user |
    | -- | ------ | ---- |
    | 1 | 1 | sandeep |
    | 2 | 1 | simi |
    | 3 | 2 | sandeep |
    | 4 | 2 | reya |
    | 5 | 3 | simi |

    * `WHERE` conditioning vs. `ON` conditioning

    ```sql
    SELECT documents.name, downloads.id
    FROM documents
    LEFT OUTER JOIN downloads
    ON documents.id=downloads.doc_id
    WHERE user='sandeep'            -- WHERE condition

    SELECT documents.name, downloads.id
    FROM documents
    LEFT OUTER JOIN downloads
    ON documents.id=downloads.doc_id
    AND user='sandeep'              -- ON condition
    ```

    * Intermediate `JOIN` table for `WHERE` conditioning
        * Matches every row using key, filters **after the join**.

    | documents.id | name | downloads.id | doc_id | user |
    | - | ---- | ------ | ------ | ------- |
    | 1 | doc1 | 1      | 1      | sandeep |
    | 1 | doc1 | 2      | 1      | simi    |
    | 2 | doc2 | 3      | 2      | sandeep |
    | 2 | doc2 | 4      | 2      | reya    |
    | 3 | doc3 | 5      | 3      | simi    |
    | 4 | doc4 | `NULL` | `NULL` | `NULL`  |
    | 5 | doc5 | `NULL` | `NULL` | `NULL`  |

    * Intermediate `JOIN` table for `ON` conditioning
        * Does not match rows that are not `user='sandeep'`, filters one table **before the join**.

    | documents.id | name | downloads.id | doc_id | user |
    | - | ---- | ------ | ------ | ------- |
    | 1 | doc1 | 1      | 1      | sandeep |
    | 2 | doc2 | 3      | 2      | sandeep |
    | 3 | doc3 | `NULL` | `NULL` | `NULL`  |
    | 4 | doc4 | `NULL` | `NULL` | `NULL`  |
    | 5 | doc5 | `NULL` | `NULL` | `NULL`  |

    * Result of `WHERE` conditioning

    | name | downloads.id |
    | ---- | ------------ |
    | doc1 |       1      |
    | doc2 |       3      |

    * Result of `ON` conditioning

    | name | downloads.id |
    | ---- | ------------ |
    | doc1 |       1      |
    | doc2 |       3      |
    | doc3 |    `NULL`    |
    | doc3 |    `NULL`    |
    | doc4 |    `NULL`    |
    | doc5 |    `NULL`    |

    * Because the `WHERE` condition filters after the `LEFT OUTER JOIN`, THE `NULL` rows of the `user` column are removed. You can see that because the `ON` condition filters before the `LEFT OUTER JOIN`, the `NULL` rows are kept in the final result.



### UNION
* Stacks two tables vertically
* Only appends `DISTINCT` values, identical rows are dropped
* Use `UNION ALL` to append all values, including identical rows
* Can write 2 `SELECT` queries, and put the results on top of each other to create one table
    * Result set's column names usually same as first `SELECT` clause
* Every `SELECT` statement within `UNION` must have same number of columns
    * The columns must have similar data types
    * The columns in every `SELECT` statement must also be in the same order

    ```sql
    -- UNION Example
    SELECT City, Country FROM Customers
    WHERE Country='Germany'
    UNION
    SELECT City, Country FROM Suppliers
    WHERE Country='Germany'

    -- Union Example
    SELECT 'Customer' AS Type, ContactName, City, Country
    FROM Customers
    UNION
    SELECT 'Supplier', ContactName, City, Country
    FROM Suppliers;

    -- UNION ALL Example
    SELECT City, Country FROM Customers
    WHERE Country='Germany'
    UNION
    SELECT City, Country FROM Suppliers
    WHERE Country='Germany'
    ORDER BY City
    ```



### UPDATE
* Updates data in a database

### DELETE
* Deletes data in a database

### INSERT INTO
* Inserts new data into a database

## SQL Database

### CREATE DATABASE
* Creates a new database

### ALTER DATABASE
* Modifies a database

### CREATE TABLE
* Creates a new table

### ALTER TABLE
* Modifies a table

### DROP TABLE
* Deletes a table

### CREATE INDEX
* Creates an index (search key)

### DROP INDEX
* Deletes an index

## Section

## References
[^1]: Footnote