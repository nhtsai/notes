---
layout: post
title: "SQL Overview"
description: "Notes on Structured Query Language."
author: "Nathan Tsai"
toc: true
comments: false
# image: 
hide: false
search_exclude: true
show_tags: false
# sticky_rank: 1
categories: [sql, mysql, postgresql]
permalink: /sql-overview
---

# SQL Overview
* [Mode SQL](https://mode.com/sql-tutorial/)
* [Select Star SQL](https://selectstarsql.com/)
* [W3 Schools SQL](https://www.w3schools.com/sql/default.asp)
* [Window Functions Video](https://www.youtube.com/watch?v=Ww71knvhQ-s)

## SQL
* **SQL**, or Structured Query Language, is a [declarative language](https://en.wikipedia.org/wiki/Declarative_programming) used to access and manipulate databases.
* SQL can execute queries, retrieve data, insert records, update records, and delete records.
* SQL can create new databases, tables, stored procedures, views.
* SQL can set permissions on tables, procedures, and views.

## RDBMS
* **RDBMS**, or Relational Database Management System, is the basis for SQL and all modern database systems (MS SQL Server, MySQL, etc.).
* A **database** is an organized collection of data tables.
* A **schema** is an overview of all tables in a database.
* A **table** is a collection of related data entries, formatted in columns and rows.
    * Every table is broken up into smaller entities called **fields**.
    * Reference a table using `database.table`.
* A **field** is a table column (vertical entity) designed to maintain specific information about every record in the table.
* A **record** is a table row (horizontal entity) that holds specific information about each individual entry that exists in a table.

## SQL Syntax
* SQL keywords are not case-sensitive.
* Semicolons separate each SQL statement, often used to execute more than one statement in the same query call.
* Use `-- comment` for single line comments, `/* comment */` for multi-line comments

### SELECT
* Extracts data from a database
* Use double-quotes for column names if column name is a keyword.

    ```sql
    -- Selecting all columns and rows
    SELECT *
    FROM table_name

    -- Using double quotes for column name (since max is a keyword)
    SELECT "Max"
    FROM table_name
    ```

### SELECT TOP/LIMIT
* Specify the number of records to return
* Use `LIMIT` for MySQL, other databases have different ones

    ```sql
    -- SQL Server/MS Access
    SELECT TOP 10 col1, col2
    FROM table_name

    -- MySQL/PostgreSQL
    SELECT col1, col2
    FROM table_name
    LIMIT 10
    ORDER BY col1 DESC -- use ORDER BY to get meaningful row order
    ```

### FROM
* Denotes the database and table to query

    ```sql
    -- Selecting all rows of col1
    SELECT col1
    FROM table_name
    ```

### WHERE
* Filters the data retrieved from the database based on a specified condition

    ```sql
    -- Filtering for rows where col1 is positive
    SELECT col1
    FROM table_name
    WHERE col1 > 0
    ```

| Comparison Operators      | Symbol |
| ------------------------- | ------ |
| Equal To                  | =      |
| Not Equal To              | <>, != |
| Greater Than              | >      |
| Greater Than or Equal To  | >=     |
| Less Than                 | <      |
| Less Than or Equal To     | <=     |

| Arithmetic Operators      | Symbol |
| ------------------------- | ------ |
| Addition                  | +      |
| Subtraction               | -      |
| Multiplication            | *      |
| Division                  | /      |

* Use operators to compare across columns in the same row.
    * Need aggregate functions to compare across rows.

| Logical Operators         | Symbol | Example |
| ------------------------- | ------ | --------|
| Match similar values      | `LIKE`, <br /> `%` is a multiple wildcard character, <br /> `_` is an individual wildcard character, <br /> `[ab]` is any single character, <br /> `[^ab]` is any single character not in brackets, <br /> `[a-b]` is any single character in a range of characters | ```WHERE col LIKE 'n%'``` |
| Match similar values, case insensitive | `ILIKE` | ```WHERE col LIKE 'n%'``` |
| Match on list of values, or query result | `IN` | ```WHERE col IN (1, 2, 3)``` |
| Match on a range, inclusive | `BETWEEN ... AND ...` | ```WHERE col BETWEEN 5 AND 10``` |
| Match null values | `IS NULL` | ```WHERE col IS NULL``` |
| Match non-null values | `IS NOT NULL` | ```WHERE col IS NOT NULL``` |
| Match on 2 conditions | `AND`| ```WHERE col >= 1 AND col <= 2``` |
| Match on either of 2 conditions | `OR`| ```WHERE col = 1 OR (col = 2 AND col = 3)``` |
| Match on not a condition | `NOT`| ```WHERE col NOT LIKE '%n%'``` <br /> ```WHERE col NOT BETWEEN 2 AND 3``` |
| Match on any values meeting condition | `ANY` | ```WHERE id = ANY(SELECT id FROM users WHERE score = 10)``` |
| Match on all values meeting condition | `ALL` | ```WHERE id != ALL(SELECT id FROM users WHERE score < 90)``` |
| Exists if subquery returns 1+ rows | `EXISTS` | ```WHERE EXISTS (SELECT id FROM users WHERE age < 18)``` |

### ORDER BY
* Sorts data based on 1+ columns
* Ascending sort by default, use `DESC` for descending sort
* Can also use #s in place of column names, corresponding to (1-indexed) order of columns in `SELECT`

    ```sql
    -- Ordering using column names
    SELECT col1, col2
    FROM table_name
    ORDER BY col1 DESC, col2

    -- Ordering using column numbers
    SELECT col1, col2
    FROM table_name
    ORDER BY 1 DESC, 2
    ```


### Aggregate Functions

| Aggregation | Command | Example |
| --- | --- | --- |
| Gets count of all non-null values | `COUNT` | ```SELECT COUNT(col1)``` |
| Gets sum of all values, null values are 0 | `SUM` | ```SELECT SUM(col1)``` |
| Gets average of all values, null values are 0 | `AVG` | ```SELECT AVG(col1)``` |
| Gets minimum of all values | `MIN` | ```SELECT MIN(col1)``` |
| Gets maximum of all values | `MAX` |  ```SELECT MAX(col1)``` |


### AS (Aliasing)
* Renames a table or column

    ```sql
    SELECT col1 AS "Sales"
    FROM table_name AS T
    ```

### GROUP BY
* Aggregates across smaller groupings instead of the whole table
* Required for non-aggregated columns when performing aggregation
* Can also reference columns by 1-indexed order in `SELECT`
* Order of column names in grouping does not matter

    ```sql
    SELECT A, B, COUNT(C)
    FROM table_name
    GROUP BY A, B

    -- Equivalent query
    SELECT A, B, COUNT(C)
    FROM table_name
    GROUP BY 2, 1
    ```

### HAVING
* Filters the result of aggregate columns
* Like `WHERE` but for aggregated columns

    ```sql
    SELECT A, MAX(B)    -- max aggregation
    FROM table_name
    WHERE A >= 4        -- filter before aggregation
    GROUP BY A          -- group by non-aggregated cols
    HAVING MAX(B) > 10  -- filter after aggregation
    ORDER BY 2 DESC     -- descending sort by MAX(B)
    LIMIT 100           -- return only first 100 rows
    ```

### CASE WHEN
* Used to handle if/else logic
* Always goes in the `SELECT` clause
* Default value is `NULL` if no `ELSE` clause

    ```sql
    SELECT CASE
            WHEN condition THEN value
            WHEN condition THEN value
            ELSE value -- optional, default is NULL
        END AS col_name
    FROM table_name
    ```

* Use with aggregate functions to create different aggregation groups
    * can use `CASE WHEN` alias in `GROUP BY` or copy and paste the whole `CASE WHEN`

    ```sql
    -- vertical table example
    SELECT CASE -- processes all c values into 5 groups
            WHEN col=1 THEN 'Freshman'
            WHEN col=2 THEN 'Sophomore'
            WHEN col=3 THEN 'Junior'
            WHEN col=4 THEN 'Senior'
        ELSE 'None'
        END AS grade,
        COUNT(1) AS count
    FROM table_name
    GROUP BY grade  -- groups by grade

    -- horizontal table example
    SELECT 
        COUNT(CASE WHEN col=1 THEN 1 ELSE NULL END) AS fr_count,
        COUNT(CASE WHEN col=2 THEN 1 ELSE NULL END) AS so_count,
        COUNT(CASE WHEN col=3 THEN 1 ELSE NULL END) AS jr_count,
        COUNT(CASE WHEN col=4 THEN 1 ELSE NULL END) AS sr_count
    FROM table_name
    ```

### DISTINCT
* Selects unique values of 1+ columns
* Only need to include `DISTINCT` once
* Slow performance, especially in aggregations

    ```sql
    SELECT DISTINCT year, month
    FROM table_name

    -- use with aggregate
    SELECT COUNT(DISTINCT month) AS unique_months
    FROM table
    ```

### Joins
* Uses common identifiers to join related tables
    * Rows without matching common identifiers will default to `NULL`
* Use aliases for tables when joining
    * Aliases distinguish identical column names when joining two tables
* Can use aliases in `SELECT` clause, like `SELECT alias.col_name`

### JOIN/INNER JOIN
* Joins two tables, returns only matched rows from both tables
* Unmatched rows are not included

    ```sql
    -- Keeps matched rows
    SELECT A.*, B.col2
    FROM table1 A
    JOIN table2 B 
    ON A.col=B.col
    ```

### LEFT JOIN/LEFT OUTER JOIN
* Joins two tables, returns matched rows and unmatched rows from left table.

    ```sql
    -- Keeps all A rows and matched B rows
    SELECT A.*, B.col2
    FROM table1 A
    LEFT JOIN table2 B 
    ON A.col=B.col
    ```

### RIGHT JOIN/RIGHT OUTER JOIN
* Joins two tables, returns matched rows and unmatched rows from right table.
* Usually use flip the table order and use `LEFT JOIN`.

    ```sql
    -- Keeps match A rows and all B rows
    SELECT A.*, B.col2
    FROM table1 A
    RIGHT JOIN table2 B 
    ON A.col=B.col
    ```

### FULL OUTER JOIN
* Joins two tables, returns all matched and unmatched rows.
* Commonly used in aggregations to find overlap between two tables

    ```sql
    -- Keeps all matched/unmatched rows
    SELECT A.*, B.col2
    FROM table1 A
    JOIN table2 B 
    ON A.col=B.col

    -- Example
    SELECT
        COUNT(
            CASE WHEN A.a IS NOT NULL AND B.b IS NULL
            THEN A.a -- must use A.a otherwise NULL and COUNT will be 0
            ELSE NULL END
        ) AS A_only,
        COUNT(
            CASE WHEN A.a IS NOT NULL AND B.b IS NOT NULL
            THEN A.a -- can keep either A.a or B.b
            ELSE NULL END
        ) AS both,
        COUNT(
            CASE WHEN A.a IS NULL AND B.b IS NOT NULL
            THEN B.b -- must use B.b otherwise NULL and COUNT will be 0
            ELSE NULL END
        ) AS B_only
    FROM table1 A
    JOIN table2 B
    ON A.a = B.b
    ```

### Joins with Conditions
* Can put conditions either in the `WHERE` or `ON` clauses

    ```sql
    -- Finds rows that fit the condition rather
    -- than joining all rows then filtering
    SELECT A.*, B.*
    FROM table1 A
    JOIN table2 B
    ON A.id = B.id
    AND A.year > B.year + 5
    ```

* Conditioning `WHERE` vs. `ON` clauses
    * `WHERE` joins all rows that match, then filters the rows based on that condition
        * May be less efficient when joining large tables
    * `ON` only joins rows that match the conditions listed
    * For `INNER JOIN`s, the two methods effectively produce the *same results* because unmatched (NULL) rows are discarded.
    * For `OUTER JOIN`s, this is a slight difference.

* Example
    * documents table

    | id | name |
    | -- | ---- |
    | 1  | doc1 |
    | 2  | doc2 |
    | 3  | doc3 |
    | 4  | doc4 |
    | 5  | doc5 |

    * downloads table

    | id | doc_id | user |
    | -- | ------ | ---- |
    | 1 | 1 | sandeep |
    | 2 | 1 | simi |
    | 3 | 2 | sandeep |
    | 4 | 2 | reya |
    | 5 | 3 | simi |


* `WHERE` conditioning vs. `ON` conditioning

    ```sql
    SELECT documents.name, downloads.id
    FROM documents
    LEFT OUTER JOIN downloads
    ON documents.id=downloads.doc_id
    WHERE user='sandeep'            -- WHERE condition

    SELECT documents.name, downloads.id
    FROM documents
    LEFT OUTER JOIN downloads
    ON documents.id=downloads.doc_id
    AND user='sandeep'              -- ON condition
    ```

* Intermediate `JOIN` table for `WHERE` conditioning
    * Matches every row using key, filters **after the join**.

    | documents.id | name | downloads.id | doc_id | user |
    | - | ---- | ------ | ------ | ------- |
    | 1 | doc1 | 1      | 1      | sandeep |
    | 1 | doc1 | 2      | 1      | simi    |
    | 2 | doc2 | 3      | 2      | sandeep |
    | 2 | doc2 | 4      | 2      | reya    |
    | 3 | doc3 | 5      | 3      | simi    |
    | 4 | doc4 | `NULL` | `NULL` | `NULL`  |
    | 5 | doc5 | `NULL` | `NULL` | `NULL`  |

* Intermediate `JOIN` table for `ON` conditioning
    * Does not match rows that are not `user='sandeep'`, filters one table **before the join**.

    | documents.id | name | downloads.id | doc_id | user |
    | - | ---- | ------ | ------ | ------- |
    | 1 | doc1 | 1      | 1      | sandeep |
    | 2 | doc2 | 3      | 2      | sandeep |
    | 3 | doc3 | `NULL` | `NULL` | `NULL`  |
    | 4 | doc4 | `NULL` | `NULL` | `NULL`  |
    | 5 | doc5 | `NULL` | `NULL` | `NULL`  |

* Result of `WHERE` conditioning

    | name | downloads.id |
    | ---- | ------------ |
    | doc1 |       1      |
    | doc2 |       3      |

* Result of `ON` conditioning

    | name | downloads.id |
    | ---- | ------------ |
    | doc1 |       1      |
    | doc2 |       3      |
    | doc3 |    `NULL`    |
    | doc3 |    `NULL`    |
    | doc4 |    `NULL`    |
    | doc5 |    `NULL`    |

* Because the `WHERE` condition filters after the `LEFT OUTER JOIN`, THE `NULL` rows of the `user` column are removed. You can see that because the `ON` condition filters before the `LEFT OUTER JOIN`, the `NULL` rows are kept in the final result.
* For `INNER JOIN`s, put join conditions in the `ON` clause and put where conditions in the `WHERE` clause.
* For `LEFT OUTER JOIN`s, put join conditions in the `ON` clause and put *where conditions that reference the right table* in the `ON` clause also.
    * Referencing the *right table* after the `LEFT JOIN` in the `WHERE` clause converts the `LEFT JOIN` into an `INNER JOIN`.
    * Exception: reference the *right table* in the `WHERE` clause when looking for records not in the table, e.g. `WHERE t2.id IS NULL`.
    * Think of conditions in the `ON` clause as "right table `WHERE` clause filters" that are applied *prior to joining*.

### Joins with Multiple Foreign Keys
* Accuracy of joining is improved
* Performances: SQL uses indexes to speed up queries
    * Using multiple join keys can speed up performance for large datasets

    ```sql
    SELECT A.col1, B.col1
    FROM table1 A
    JOIN table2 B
    ON A.id = B.id AND A.col = B.col
    ```


### Self Joins
* Joins a table with itself
* Self joins can help compare different records of the same table

    ```sql
    -- WHERE: Find pairs from the same city
    SELECT A.name, B.name, A.city
    FROM users A, users B
    WHERE A.id <> B.id      -- avoid matching users to themselves
    AND A.city = B.city     -- find pairs from the same city

    -- ON: Find all pairs
    SELECT A.name, B.name
    FROM table1 A
    JOIN table1 B
    ON A.id != B.id -- prevents identical pairs, e.g. (5, 5)

    -- ON: Find all unique pairs
    SELECT A.name, B.name
    FROM table1 A
    JOIN table1 B
    ON A.id < B.id -- prevents identical pairs and permutations, e.g. (1, 5) but not (5, 1)

    -- ON: Find unique pairs of duplicates
    SELECT A.name, B.name
    FROM table1 A
    JOIN table1 B
    ON A.id < B.id      -- gets different pairs
    AND A.last = B.last -- with the same value, eg. different people with same last name
    ```


### UNION
* Stacks two tables vertically
* Only appends `DISTINCT` values, identical rows are dropped
* Use `UNION ALL` to append all values, including identical rows
* Can write 2 `SELECT` queries, and put the results on top of each other to create one table
    * Result set's column names usually same as first `SELECT` clause
* Every `SELECT` statement within `UNION` must have same number of columns
    * The columns must have similar data types
    * The columns in every `SELECT` statement must also be in the same order

    ```sql
    -- UNION Example
    SELECT City, Country FROM Customers
    WHERE Country='Germany'
    UNION
    SELECT City, Country FROM Suppliers
    WHERE Country='Germany'

    -- Union Example
    SELECT 'Customer' AS Type, ContactName, City, Country
    FROM Customers
    UNION
    SELECT 'Supplier', ContactName, City, Country
    FROM Suppliers;

    -- UNION ALL Example
    SELECT City, Country FROM Customers
    WHERE Country='Germany'
    UNION
    SELECT City, Country FROM Suppliers
    WHERE Country='Germany'
    ORDER BY City
    ```


### Data Types
* Differences vary across various versions of SQL

| Imported As | Stored As |
| ----------- | --------- |
| String      | `VARCHAR(1024)` |
| Date/Time   | `DATE`, `DATETIME`, `TIMESTAMP`, `INTERVAL`, `YEAR` |
| Number      | Exact: `INTEGER`, `SMALLINT`, `DECIMAL`, `NUMERIC` <br /> Approx: `FLOAT`, `REAL`, `DOUBLE PRECISION` |
| Boolean     | `BOOLEAN` |

### CAST
* In MySQL, changes data type of a column
* In PostgreSQL, can also use `expression::type` casting syntax

    ```sql
    SELECT CAST(col AS Integer) AS int_col
    FROM table_name
    WHERE CAST(col AS Integer) > 10
    ```

### Dates
* `DATE`, `DATETIME`, `TIMESTAMP` are date types used in SQL versions
* `YYYY-MM-DD` is used for easy ordering, identical orders for dates and strings
* Date ranges are stored as `INTERVAL`
    * Intervals are defined in English terms, e.g. 10 seconds, 5 days, or 2 months

    ```sql
    -- Using intervals
    SELECT (CAST(table_name.date AS Timestamp) + INTERVAL '1 week') AS week_after
    FROM table_name
    ```

* `EXTRACT(field FROM date_col)`: helps deconstruct dates
    * `field` includes: `YEAR`, `MONTH`, `DAY`, `HOUR`, `SECOND`, `DECADE`, `DOW` (day of week)

    ```sql
    SELECT EXTRACT(YEAR FROM date_col) AS year
    FROM table_name
    ```

* `DATE_TRUNC(field, date_col)`: rounds date to a specified precision
    * `field` includes: `YEAR`, `MONTH`, `DAY`, `HOUR`, `SECOND`, `DECADE`

    ```sql
    SELECT DATE_TRUNC(DAY, date_col) AS rounded_day
    FROM table_name
    ```

* System Datetime Variables
    * `CURRENT_DATE()`
    * `CURRENT_TIME()`
    * `CURRENT_TIMESTAMP()`
    * `LOCALTIME()`
    * `LOCALTIMESTAMP()`
    * `NOW()`
    * To any above, can add `AT TIME ZONE timezone_code` to convert to a different timezone.

    ```sql
    SELECT NOW()

    SELECT CURRENT_DATE() AT TIME ZONE 'PST' AS current_date_pst
    ```

### Null Functions
* Functions vary by SQL version
* `IFNULL(col, value)`: returns default value if expression is null
* `COALESCE(col, value)`: returns default value if expression is null

    ```sql
    SELECT name, price * (inventory + COALESCE(ordered, 0))
    FROM products
    ```

### String Functions

* `LEFT(str, n)`: get n characters from left end of string
* `RIGHT(str, n)`: get n characters from right end of string
* `TRIM(type chars FROM str)`: trim characters from string
    * `TRIM(both '()' FROM col1)`: trim from both ends
    * `TRIM(leading '()' FROM col1)`: trim from front
    * `TRIM(trailing '()' FROM col1)`: trim from back
* `POSITION(substr IN str)`: get position of substring in string, case-sensitive
* `STRPOS(str, substr)`: get position of substring in string, case-sensitive
* `SUBSTR(str, start_idx, n)`: get n-length substring starting at index of string
* `CONCAT(str, str, ...)`: concatenate strings
* `str || str || ...`: concatenate strings
* `UPPER(str)`: convert string to upper case
* `LOWER(str)`: convert string to lower case

## Subqueries
* Subqueries are nested/inner queries to perform operations in multiple steps
* Subqueries are required to have aliases

    ```sql
    SELECT sub.*
    FROM (
        SELECT *
        FROM students
        WHERE grade > 80
    ) sub
    WHERE sub.class_level = 'Senior'
    ```

* Example: How many incidents happen, on average, on Fridays in December?

    ```sql
    -- Count # of incidents that happen on each day.
    -- Average # of daily incidents over each day of week (5: Friday) in month (December).
    SELECT EXTRACT(MONTH FROM sub.incident_date) AS "Month",
           sub.day_of_week,
           AVG(sub.daily_incidents)
    FROM (
        SELECT EXTRACT(DOW FROM incident_date) AS day_of_week,
               incident_date,
               COUNT(incident_id) AS incidents
        FROM log_table
        GROUP BY 1, 2
    ) sub
    WHERE sub.day_of_week = 5 AND EXTRACT(MONTH FROM sub.incident_date) = 12
    ```

* Example: How many incidents happen for each category, averaged over all months?

    ```sql
    -- Count # of incidents per category that happen on each month
    -- Average # of incidents per category over all months
    SELECT sub.category,
           AVG(sub.incidents) AS avg_incidents_per_month
    FROM (
        SELECT EXTRACT(MONTH FROM incident_date) AS "month",
            category,
            COUNT(incident_id) as incidents
        FROM log_table
        GROUP BY 1, 2
    ) sub
    GROUP BY 1
    ```

* Subqueries in Conditional Logic
    * Don't use aliases for subqueries in conditional statements

    * Example: get all products that have min price

    ```sql
    SELECT *
    FROM products
    WHERE price = (SELECT MIN(price) FROM products) -- subquery returns single cell
    ```

    * Example: get the products in the top 5 prices

    ```sql
    SELECT *
    FROM products
    WHERE price IN (
        SELECT DISTINCT price
        FROM products
        ORDER BY price DESC
        LIMIT 5
    ) -- subquery returns multiple cells (of one column)
    ```

* Joining Subqueries
    * Using filtering in the `ON` clause can handle cases when subquery returns one or multiple rows
    * `ON` filtering is the same as `WHERE` filtering for `INNER JOINS`

    * Example: get the products in the top 5 prices

    ```sql
    SELECT *
    FROM products
    JOIN (
        SELECT DISTINCT price
        FROM products
        ORDER BY price DESC
        LIMIT 5
    ) sub
    ON products.price = sub.price
    ```

* Joining Subqueries with Aggregation Functions

    * Example: [Find the products from the top 3 categories with the least counts.](http://sqlfiddle.com/#!9/06d2bf/3/0)

    ```sql
    -- subquery returns top 3 categories with least product counts
    -- query selects all products in the specified 3 categories
    -- result set is ordered by count and descending price
    -- (products with same category have same counts)
    SELECT products.*, sub.c AS counts
    FROM products
    JOIN (
        SELECT category, COUNT(id) AS c
        FROM products
        GROUP BY category
        ORDER BY c
        LIMIT 3
    ) sub
    ON products.category = sub.category
    ORDER BY sub.c, products.price DESC
    ```

    * Unlike using `WHERE col IN (subquery)`, `JOIN (subquery) ON table.col=sub.col` allows  aggregated values to be passed into the outer query because an `IN` clause is limited to one set of values.
        * Additionally, MySQL does not allow `LIMIT` in subqueries in the `WHERE` clause.

* Using Subqueries to Improve Performance
    * Inefficient: `FULL JOIN` creates a huge intermediate join table

    ```sql
    -- Get counts of A and B entities per month
    SELECT COALESCE(A.month, B.month) AS month, -- fill null values of outer join
           COUNT(DISTINCT A.id) AS count_A,
           COUNT(DISTINCT B.id) AS count_B
    FROM A
    FULL OUTER JOIN B -- creates a large intermediate join table
    ON A.month = B.month
    GROUP BY 1
    ```

    * Intermediate Join Table

        | A.id   | A.month | B.month | B.id   |
        | ------ | ------- | ------- | ------ |
        | 1      | A       | A       | 5      |
        | 1      | A       | A       | 6      |
        | 2      | B       | B       | 7      |
        | 3      | B       | B       | 7      |
        | 4      | C       | `NULL`  | `NULL` |
        | `NULL` | `NULL`  | D       | 8      |

    * Result

        | month | count_A | count_B |
        | ----- | ------- | ------- |
        | A     | 1       | 2       |
        | B     | 2       | 1       |
        | C     | 1       | 0       |
        | D     | 0       | 1       |


    * Optimized: Use subqueries to divide the problem into smaller tables before joining

    ```sql
    -- Get counts of A and B entities per month
    -- Pre-aggregate counts in A and B separately before joining 
    SELECT COALESCE(A.month, B.month) as month,
           subA.count_A,
           subB.count_B
    FROM (
        SELECT month, COUNT(DISTINCT id) AS count_A
        FROM A
        GROUP BY 1
    ) subA
    FULL OUTER JOIN (
        SELECT month, COUNT(DISTINCT id) AS count_B
        FROM B
        GROUP BY 1
    ) subB
    ON subA.month = subB.month
    ```

    * Intermediate Join Tables

        | month | count_A |
        | ----- | ------- |
        | A     | 1       |
        | B     | 2       |
        | C     | 1       |

        | month | count_B |
        | ----- | ------- |
        | A     | 2       |
        | B     | 1       |
        | D     | 1       |

    * Result

        | month | count_A | count_B |
        | ----- | ------- | ------- |
        | A     | 1       | 2       |
        | B     | 2       | 1       |
        | C     | 1       | 0       |
        | D     | 0       | 1       |

* The two methods get the same result, but the join using subqueries is faster because operating on smaller intermediate join tables is more efficient.
    * Method 1 joins both tables then gets counts for A and B per month.
    * Method 2 gets counts for A and B per month separately, then joins the results together.


### Window Functions
* A **window** is a group of related rows that are somehow related the current row, e.g. all rows with same month or same city
* A **window function** performs calculation across a window, 
    * Unlike aggregation functions, window functions don't group rows into a single output row
        * No need to group by non-aggregated rows
    * Window functions are able to access more than just the current row of query result
    * A **window function** takes in a column/row and a window of related rows that includes the row

* Aggregation functions can serve as window functions
    * Inside `OVER()`, use `ORDER BY` to sort the window by a column
    * Cannot use `GROUP BY` with window functions

    ```sql
    SELECT SUM(col) OVER (...)
    SELECT COUNT(col) OVER (...)
    SELECT AVG(col) OVER (...)

    -- Example: Get a running total
    -- Using SUM as a window function
    -- ORDER BY to calculate chronologically
    SELECT duration,
           SUM(duration) OVER (ORDER BY start_time) AS running_total
    FROM rides
    ```

    * Window Result
        * Durations are summed and ordered by start_time to create a running total
        * Without `ORDER BY`, each value would be sum of all seconds in its partition

    | duration | running_total |
    | -------- | ------------- |
    | 1        | 1             |
    | 1        | 2             |
    | 2        | 4             |
    | 1        | 5             |
    | 4        | 9             |
    | 3        | 12            |

* Apply window function over individual groups
    * Inside `OVER()`, use `PARTITION BY` to specify how the window function builds the window
        * Each partition will be treated as one window, upon which the function will be applied
    * Without `PARTITION BY`, the whole table will be treated as one window

    ```sql
    -- using aggregation, cannot get individual information from all employees
    SELECT dept_name, MAX(salary) AS max_salary
    FROM employees
    GROUP BY dept_name

    -- better to use window function
    -- PARTITION BY specifies how to group rows to form a window
    SELECT E.*,
           MAX(salary) OVER(PARTITION BY dept_name) AS max_salary
    FROM employees E
    ```

    * The aggregation will return each department and the max salary of that department, without any other employee data.
    * The window function will return every employee data with the max salary of the department that employee works in
        * The window function duplicates the department's max salary to every row
        * Without `PARTITION BY`, the max salary of all departments will be duplicated for every row

* `ROW_NUMBER()`: window function that returns number of row

* `RANK()`: window function that ranks values
    * Like `ROW_NUMBER()` but gives same values when tied, e.g. 1, 2, 2, 4, 4, 4, 7

* `DENSE_RANK()`: window function that ranks values without skipping numbers
    * Like `RANK()` but does not skip values, e.g. 1, 2, 2, 3, 3, 3, 4

    ```sql
    SELECT team, score,
           ROW_NUMBER(score) OVER(PARTITION BY team ORDER BY score),
           RANK(score) OVER(PARTITION BY team ORDER BY score),
           DENSE_RANK(score) OVER(PARTITION BY team ORDER BY score)
    FROM table_name
    ```

    | Team | Score | `ROW_NUMBER()` | `RANK()` | `DENSE_RANK()` |
    | ---- | ----- | -------------- | -------- | -------------- |
    | A    | 30    | 1              | 1        | 1              |
    | A    | 40    | 2              | 2        | 2              |
    | A    | 40    | 3              | 2        | 2              |
    | A    | 55    | 4              | 4        | 3              |
    | B    | 20    | 1              | 1        | 1              |
    | B    | 20    | 2              | 1        | 1              |
    | B    | 35    | 3              | 3        | 2              |
    | C    | 20    | 1              | 1        | 1              |


    ```sql
    -- Fetch the top 3 employees in each department by salary
    -- Using ROW_NUMBER() may miss out on other employees tied for top 3 salary values
    SELECT *
    FROM (
        SELECT E.*,
               ROW_NUMBER() OVER (PARTITION BY dept_name ORDER BY salary DESC) AS salary_num
        FROM employee E
    ) sub
    WHERE sub.salary_num < 4

    -- Fetch the top employees in each department
    -- who earn the top 3 salaries in their department
    -- Returns every employee earning one of the top 3 salaries in their department
    SELECT *
    FROM (
        SELECT E.*,
               RANK() OVER (PARTITION BY dept_name ORDER BY salary DESC) AS salary_rank
        FROM employee E
    ) sub
    WHERE sub.salary_rank < 4
    ```

* `NTILE(n)`: window function that determines which bucket row falls in
    * e.g. use n = 4 for quartile, or n = 100 for percentile
    * For small partition rows with less rows than tiles, the tiles will resemble a numerical ranking

    ```sql
    -- get quartile and percentile of student scores for each class
    SELECT class,
           score,
           NTILE(4) OVER (PARTITION BY class ORDER BY score DESC) AS quartile,
           NTILE(100) OVER (PARTITION BY class ORDER BY score DESC) AS percentile
    FROM table_name
    ```

* `LAG(col, n)`: window function that creates a column that pulls from the previous n rows of col
    * First n rows of column will be `NULL` because no previous rows to pull from
    * Some versions of SQL allow default values, i.e. `LAG(col, n, default)`, to fill in `NULL` values

* `LEAD(col, n)`: window function that creates a column that pulls from next n rows of col
    * Last n rows of column will be `NULL` because no previous rows to pull from
    * Some versions of SQL allow default values, i.e. `LEAD(col, n, default)`, to fill in `NULL` values

    ```sql
    -- Example of lag and lead score, partitioned on team
    SELECT team,
           score,
           LAG(score, 1) OVER (PARTITION BY team ORDER BY score) AS lag_score,
           LEAD(score, 1) OVER (PARTITION BY team ORDER BY score) AS lead_score
    FROM table_name
    ```

    | team | score | lag_score | lead_score |
    | ---- | ----- | --------- | ---------- |
    | A    | 20    | `NULL`    | 30         |
    | A    | 30    | 20        | 40         |
    | A    | 40    | 30        | `NULL`     |
    | B    | 30    | `NULL`    | 60         |
    | B    | 60    | 30        | 70         |
    | B    | 70    | 50        | 75         |
    | B    | 75    | 70        | `NULL`     |


    ```sql
    -- Show if the salary of an employee is higher, lower, or equal to the previous employee.
    SELECT E.*,
           LAG(salary, 1, 0) OVER (PARTITION BY dept_name ORDER BY id) AS prev_emp_salary,
           CASE WHEN E.salary > LAG(salary, 1, 0) OVER (PARTITION BY dept_name ORDER BY id THEN 'Higher'
           WHEN E.salary < LAG(salary, 1, 0) OVER (PARTITION BY dept_name ORDER BY id) THEN 'Lower'
           ELSE 'Equal' END AS salary_range
    FROM employee E
    ```

    | id | name | dept_name | salary | prev_emp_salary | salary_range |
    | -- | ---- | --------- | ------ | --------------- | ------------ |
    |  1 | Anna | Admin     |   4000 |               0 | Higher       |
    |  3 | Bert | Admin     |   5000 |            4000 | Higher       |
    |  4 | Dirk | Admin     |   3000 |            5000 | Lower        |
    |  6 | Cris | Admin     |   6000 |            3000 | Higher       |
    |  2 | Kurt | Finance   |   4000 |               0 | Higher       |
    |  5 | Fred | Finance   |   5000 |            4000 | Higher       |
    |  7 | Paul | Finance   |   5000 |            5000 | Equal        |
    |  8 | Evan | Finance   |   2000 |            5000 | Lower        |


    ```sql
    -- Example of removing null rows using subquery
    SELECT sub.*
    FROM (
        SELECT location,
               duration - LAG(duration, 1) OVER (PARTITION BY location ORDER BY duration) AS difference
        FROM rides
    ) sub
    WHERE sub.difference IS NOT NULL
    ```

* Window Aliases
    * can name and re-use same window for several queries
    * should always come after the `WHERE` clause

    ```sql
    SELECT location,
           duration,
           NTILE(4) OVER ntile_window AS quartile,
           NTILE(100) OVER ntile_window AS percentile
    FROM rides
    WINDOW ntile_window AS (PARTITION BY location ORDER BY duration) -- window alias
    ORDER BY location, duration
    ```



### SELECT INTO
* Copies data from one table into a new table (in external database)

    ```sql
    SELECT *
    INTO adults IN 'backup.db' -- optional: [IN external_db]
    FROM users
    WHERE age >= 18
    ```

### UPDATE
* Modifies existing records in a table

    ```sql
    UPDATE table_name
    SET col1 = val1, col2 = val2, ...
    WHERE condition -- without WHERE clause, all rows will be updated
    ```

### DELETE
* Deletes data in a database

### INSERT INTO
* Inserts new data into a database

    ```sql
    -- specifying which columns, values to insert
    INSERT INTO table_name (col1, col2, col3, ...)
    VALUES (val1, val2, val3, ...)

    -- don't need to specify if adding all columns
    INSERT INTO table_name
    VALUES (val1, val2, val3, val4, val5)
    ```

### INSERT INTO SELECT
* Copies data from one table and inserts it into another table
* data types in source and destination tables must match

    ```sql
    INSERT INTO all_profits
    SELECT * FROM current_profits
    WHERE company = 'Apple'
    ```

### Common Table Expressions (CTE)
* A temporary named result set that can be referenced within `SELECT`, `INSERT`, `UPDATE`, or `DELETE` statements, also used in a `CREATE` to create a view
* Advantage over subqueries: CTEs can be use multiple times in a query

    ```sql
    -- Find average grades for every senior student
    WITH cte_student_grades (student, class_year, avg_grade) AS (
        SELECT 
            S.first_name + ' ' + S.last_name,
            YEAR(S.graduation_date),
            AVG(E.grade)
        FROM students S
        JOIN exams E
        ON S.id = E.student_id
        GROUP BY first_name + ' ' + last_name, YEAR(graduation_date)
    )
    -- use CTE in a SELECT statement
    SELECT student, avg_grade, 'Senior' AS class_level
    FROM cte_student_grades
    WHERE class_year = 2021
    ```

* Use to perform multi-level aggregations, e.g. average minimum grade `AVG(MIN(grade))`
    * SQL does not allow subqueries or aggregate functions inside an aggregate function
    * SO you have to do `MIN(grade)` first in a CTE, then do `AVG(min_grade)`

    ```sql
    -- Find average min and average max exam grades across all subjects
    WITH min_max_grade AS (
        SELECT  SU.id,
                SU.subject_name,
                MIN(E.grade) AS min_grade,
                MAX(E.grade) AS max_grade
        FROM subjects SU
        JOIN exams E
        ON SU.id = E.subject_id
        GROUP BY SU.id, SU.subject_name
    )

    SELECT AVG(min_grade) AS avg_min_grade,
           AVG(max_grade) AS avg_max_grade
    FROM min_max_grade; -- use CTE in a query

    -- Alternatively, subqueries are not as readable, reusable,
    -- and opposite in terms of thought process (AVG -> MIN/MAX)
    SELECT AVG(min_grade) AS avg_min_grade,
           AVG(max_grade) AS avg_max_grade
    FROM (
        SELECT SU.id,
               SU.subject_name,
               MIN(E.grade) AS min_grade
               MAX(E.grade) AS max_grade
        FROM subjects SU
        JOIN exams E
        ON SU.id = E.subject_id
        GROUP BY 1, 2
    )
    ```


### Stored Procedures
* A prepared SQL code that can be saved and reused, like a function

    ```sql
    -- Storing procedure
    CREATE PROCEDURE SelectAllUsers
    AS
        SELECT *
        FROM Users
    GO

    -- Executing procedure
    EXEC SelectAllUsers
    ```

* A procedure can take in parameters

    ```sql
    -- Storing procedure
    CREATE PROCEDURE SelectAllUsers @City nvarchar(30), @MinAge Int
    AS
        SELECT *
        FROM Users
        WHERE city = @City AND age >= @MinAge
    GO

    -- Executing procedure
    EXEC SelectAllUsers @City = 'Los Angeles', @MinAge = 18
    ```

## SQL Database

### CREATE DATABASE
* Creates a new database: `CREATE DATABASE testDB`

### DROP DATABASE
* Drop an existing database: `DROP DATABASE testDB`

### BACKUP DATABASE
* Create full backup of existing database

    ```sql
    BACKUP DATABASE testDB
    TO DISK = 'D:\backups\latest_backup.bak'
    WITH DIFFERENTIAL -- include to only back up changes since last full backup
    ```

## SQL Table

* Creating a table

    ```sql
    -- Create new table
    CREATE TABLE Users (
        id int,
        name varchar(255),
        city varchar(255),
        age int,
        is_loyal boolean
    )

    -- Create new table from another table
    CREATE TABLE NYC_Users AS
    SELECT id, name, city, age
    FROM Users
    WHERE city = 'New York City'
    ```

### SQL Constraints
* Specifies rules for the data in the table

| Constraint       | Function                                                 |
| ---------------- | -------------------------------------------------------- |
| `NOT NULL`       | column cannot have null values                           |
| `UNIQUE`         | column has all different values                          |
| `PRIMARY KEY`    | column is `NOT NULL` and `UNIQUE`, serves as row id      |
| `FOREIGN KEY`    | prevents actions that would destroy links between tables |
| `CHECK`          | ensures column values specify a specific condition       |
| `DEFAULT`        | set default value for column if no value specified       |
| `CREATE INDEX`   | used to quickly create and retrieve data from database   |
| `AUTO_INCREMENT` | starting from 1, increments by 1 every time row inserted |

    ```sql
    -- Create table with various constraints
    CREATE TABLE Users (
        id int NOT NULL AUTO_INCREMENT,
        dept_id int NOT NULL,
        full_name varchar(255) NOT NULL,
        email varchar(255) UNIQUE,
        age int,
        city varchar(255) DEFAULT 'Seattle',
        CHECK (age >= 18),
        PRIMARY KEY (id),
        FOREIGN KEY (dept_id)
    )
    ```

* Alter or add, delete, modify columns or various constraints of a table

    ```sql
    -- Add column
    ALTER TABLE Users
    ADD email VARCHAR(255)

    -- Drop column
    ALTER TABLE Users
    DROP column is_loyal

    -- Change datatype
    ALTER TABLE Users
    MODIFY COLUMN city varchar(300)
    ```

* Remove a table

    ```sql
    -- Delete a table
    DROP TABLE Users

    -- Truncate: delete data inside but not table itself
    TRUNCATE TABLE Users
    ```

### SQL Index
* An index is used to retrieve data more quickly, not seen by users

    ```sql
    -- Create index
    CREATE INDEX idx_name
    ON Users (last_name)
    
    -- Create unique index
    CREATE UNIQUE INDEX idx_name 
    ON Users (first_name, last_name)

    -- Drop index
    DROP INDEX idx_name ON Users
    ```

### Views
* A virtual table based on the result-set of an SQL statement

    ```sql
    -- Create the view
    CREATE VIEW [Luxury Products] AS
    SELECT product_name, price
    FROM products
    WHERE price > (SELECT AVG(price) FROM products)

    -- Query the view
    SELECT * FROM [Luxury Products]


    -- Update the view
    CREATE OR REPLACE VIEW [Luxury Products] AS
    SELECT product_name, price
    FROM products
    WHERE price > (SELECT AVG(price) FROM products)

    -- Drop the View
    DROP VIEW [Luxury Products]
    ```

## References
[^1]: Footnote